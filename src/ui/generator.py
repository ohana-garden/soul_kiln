"""
AI UI Generator.

Generates UI specifications based on conversation context.
The AI decides every pixel - layout, components, content, styling.

The generator receives:
- Current topic state (active concepts, virtues, region)
- Active artifacts (images, documents, maps, etc.)
- Conversation history
- Emotional state

And produces a UISpec describing what to render.
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable

logger = logging.getLogger(__name__)


class ComponentType(str, Enum):
    """Types of UI components the AI can generate."""

    # Layout
    CONTAINER = "container"
    COLUMNS = "columns"
    EXPANDER = "expander"
    TABS = "tabs"

    # Content
    TEXT = "text"
    MARKDOWN = "markdown"
    HEADER = "header"
    SUBHEADER = "subheader"
    CAPTION = "caption"
    CODE = "code"
    DIVIDER = "divider"

    # Media
    IMAGE = "image"
    AUDIO = "audio"
    VIDEO = "video"

    # Data
    DATAFRAME = "dataframe"
    TABLE = "table"
    METRIC = "metric"
    JSON = "json"

    # Charts
    LINE_CHART = "line_chart"
    BAR_CHART = "bar_chart"
    AREA_CHART = "area_chart"
    SCATTER_CHART = "scatter_chart"
    MAP = "map"
    GRAPH = "graph"  # Network graph

    # Interactive
    BUTTON = "button"
    TEXT_INPUT = "text_input"
    TEXT_AREA = "text_area"
    SELECTBOX = "selectbox"
    SLIDER = "slider"
    CHECKBOX = "checkbox"

    # Special
    ARTIFACT = "artifact"  # Renders an artifact from the KB
    CONVERSATION = "conversation"  # Chat-style display
    VIRTUE_DISPLAY = "virtue_display"  # Virtue activation visualization
    TOPIC_INDICATOR = "topic_indicator"  # Current topic region


@dataclass
class UIComponent:
    """A single UI component to render."""

    type: ComponentType
    content: Any = None  # Main content (text, data, etc.)
    props: dict = field(default_factory=dict)  # Component properties
    style: dict = field(default_factory=dict)  # CSS-like styling
    children: list["UIComponent"] = field(default_factory=list)  # Nested components
    id: str = ""  # Optional ID for interactivity

    def to_dict(self) -> dict:
        return {
            "type": self.type.value,
            "content": self.content,
            "props": self.props,
            "style": self.style,
            "children": [c.to_dict() for c in self.children],
            "id": self.id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "UIComponent":
        return cls(
            type=ComponentType(data["type"]),
            content=data.get("content"),
            props=data.get("props", {}),
            style=data.get("style", {}),
            children=[cls.from_dict(c) for c in data.get("children", [])],
            id=data.get("id", ""),
        )


@dataclass
class UISpec:
    """Complete UI specification generated by AI."""

    components: list[UIComponent]
    layout: str = "single"  # "single", "sidebar", "wide"
    theme: dict = field(default_factory=dict)  # Color scheme, fonts
    title: str = ""
    page_icon: str = ""

    def to_dict(self) -> dict:
        return {
            "components": [c.to_dict() for c in self.components],
            "layout": self.layout,
            "theme": self.theme,
            "title": self.title,
            "page_icon": self.page_icon,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "UISpec":
        return cls(
            components=[UIComponent.from_dict(c) for c in data.get("components", [])],
            layout=data.get("layout", "single"),
            theme=data.get("theme", {}),
            title=data.get("title", ""),
            page_icon=data.get("page_icon", ""),
        )


# System prompt for the UI generator
UI_GENERATOR_PROMPT = """You are a UI generator for Soul Kiln, a virtue-based AI system.

Your job is to generate a UI specification (JSON) that best serves the current conversation.
Every pixel you specify should serve understanding and communication.

PRINCIPLES:
1. Content serves communication - show what helps the user understand
2. No decoration for its own sake - every element has purpose
3. Artifacts (images, documents, maps) should be prominent when relevant
4. The graph visualization is available but secondary to useful content
5. Match the emotional tone of the conversation

CONTEXT PROVIDED:
- topic_state: Current conversation topic (region, active concepts, virtues)
- artifacts: Available artifacts to display (images, documents, etc.)
- conversation: Recent conversation turns
- emotional_state: User's emotional state (if available)

OUTPUT FORMAT:
Return a JSON object with this structure:
{
  "layout": "single" | "sidebar" | "wide",
  "title": "Page title",
  "theme": {"primary_color": "#hex", "background": "#hex"},
  "components": [
    {
      "type": "component_type",
      "content": "content or data",
      "props": {"prop": "value"},
      "style": {"css_prop": "value"},
      "children": []
    }
  ]
}

COMPONENT TYPES:
- Layout: container, columns, expander, tabs
- Text: text, markdown, header, subheader, caption, code, divider
- Media: image, audio, video
- Data: dataframe, table, metric, json
- Charts: line_chart, bar_chart, map, graph
- Interactive: button, text_input, text_area, selectbox
- Special: artifact, conversation, virtue_display, topic_indicator

EXAMPLES:

For a conversation about plant pests with an aphid image artifact:
{
  "layout": "wide",
  "components": [
    {"type": "header", "content": "Identifying Aphids on Tomatoes"},
    {"type": "columns", "props": {"ratio": [2, 1]}, "children": [
      {"type": "container", "children": [
        {"type": "artifact", "content": "aphid_image_id", "props": {"caption": "Aphid infestation on tomato leaf"}},
        {"type": "markdown", "content": "**What to look for:** Small green or black insects..."}
      ]},
      {"type": "container", "children": [
        {"type": "subheader", "content": "Quick Facts"},
        {"type": "metric", "content": {"label": "Severity", "value": "Moderate", "delta": "spreading"}}
      ]}
    ]},
    {"type": "conversation", "props": {"show_last": 3}}
  ]
}

For exploring the virtue graph:
{
  "layout": "wide",
  "components": [
    {"type": "graph", "content": "virtue_graph", "props": {"highlight": ["V01", "V02"]}},
    {"type": "virtue_display", "props": {"show_activations": true}}
  ]
}

Generate UI that serves the user's current needs. Be creative but purposeful."""


class UIGenerator:
    """
    Generates UI specifications using an LLM.

    The AI decides what to show based on:
    - Current topic and active concepts
    - Available artifacts
    - Conversation context
    - Emotional state
    """

    def __init__(self, llm_fn: Callable[[str, str], str] | None = None):
        """
        Initialize the generator.

        Args:
            llm_fn: Function that takes (system_prompt, user_prompt) -> response
        """
        self._llm_fn = llm_fn
        self._last_spec: UISpec | None = None
        self._generation_count = 0

    def set_llm(self, llm_fn: Callable[[str, str], str]) -> None:
        """Set the LLM function."""
        self._llm_fn = llm_fn

    def generate(
        self,
        topic_state: dict | None = None,
        artifacts: list[dict] | None = None,
        conversation: list[dict] | None = None,
        emotional_state: dict | None = None,
        user_request: str | None = None,
    ) -> UISpec:
        """
        Generate a UI specification for the current context.

        Args:
            topic_state: Current topic state from TopicDetector
            artifacts: Available artifacts from ArtifactCurator
            conversation: Recent conversation turns
            emotional_state: Emotional state from Hume integration
            user_request: Optional explicit user request for UI

        Returns:
            UISpec describing what to render
        """
        if not self._llm_fn:
            # Fallback to default UI if no LLM
            return self._default_ui(topic_state, artifacts, conversation)

        # Build context for LLM
        context = self._build_context(
            topic_state, artifacts, conversation, emotional_state, user_request
        )

        try:
            # Generate UI spec via LLM
            response = self._llm_fn(UI_GENERATOR_PROMPT, context)
            spec = self._parse_response(response)
            self._last_spec = spec
            self._generation_count += 1
            return spec

        except Exception as e:
            logger.error(f"UI generation failed: {e}")
            return self._default_ui(topic_state, artifacts, conversation)

    def _build_context(
        self,
        topic_state: dict | None,
        artifacts: list[dict] | None,
        conversation: list[dict] | None,
        emotional_state: dict | None,
        user_request: str | None,
    ) -> str:
        """Build the context string for the LLM."""
        context_parts = []

        if user_request:
            context_parts.append(f"USER REQUEST: {user_request}")

        if topic_state:
            context_parts.append(f"TOPIC STATE:\n{json.dumps(topic_state, indent=2)}")

        if artifacts:
            context_parts.append(f"AVAILABLE ARTIFACTS:\n{json.dumps(artifacts, indent=2)}")

        if conversation:
            # Last 5 turns
            recent = conversation[-5:] if len(conversation) > 5 else conversation
            context_parts.append(f"RECENT CONVERSATION:\n{json.dumps(recent, indent=2)}")

        if emotional_state:
            context_parts.append(f"EMOTIONAL STATE:\n{json.dumps(emotional_state, indent=2)}")

        if not context_parts:
            context_parts.append("No specific context. Generate a welcoming default UI.")

        return "\n\n".join(context_parts)

    def _parse_response(self, response: str) -> UISpec:
        """Parse LLM response into UISpec."""
        # Extract JSON from response (may be wrapped in markdown)
        json_str = response

        if "```json" in response:
            start = response.find("```json") + 7
            end = response.find("```", start)
            json_str = response[start:end].strip()
        elif "```" in response:
            start = response.find("```") + 3
            end = response.find("```", start)
            json_str = response[start:end].strip()

        try:
            data = json.loads(json_str)
            return UISpec.from_dict(data)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse UI spec JSON: {e}")
            raise

    def _default_ui(
        self,
        topic_state: dict | None,
        artifacts: list[dict] | None,
        conversation: list[dict] | None,
    ) -> UISpec:
        """Generate a default UI when LLM is unavailable."""
        components = []

        # Header
        components.append(UIComponent(
            type=ComponentType.HEADER,
            content="Soul Kiln"
        ))

        # Topic indicator if available
        if topic_state:
            components.append(UIComponent(
                type=ComponentType.TOPIC_INDICATOR,
                content=topic_state
            ))

        # Show artifacts if available
        if artifacts:
            for artifact in artifacts[:3]:
                components.append(UIComponent(
                    type=ComponentType.ARTIFACT,
                    content=artifact.get("id"),
                    props=artifact
                ))

        # Conversation display
        components.append(UIComponent(
            type=ComponentType.CONVERSATION,
            content=conversation or [],
            props={"show_last": 10}
        ))

        # Input area
        components.append(UIComponent(
            type=ComponentType.TEXT_INPUT,
            props={"placeholder": "Type your message...", "key": "user_input"}
        ))

        return UISpec(
            components=components,
            layout="single",
            title="Soul Kiln",
        )

    def regenerate(self) -> UISpec | None:
        """Regenerate UI with same context."""
        # Would need to store last context - for now just return last spec
        return self._last_spec


# Singleton
_generator: UIGenerator | None = None


def get_ui_generator() -> UIGenerator:
    """Get the singleton UI generator."""
    global _generator
    if _generator is None:
        _generator = UIGenerator()
    return _generator
