"""
Streamlit Renderer.

Renders UISpec (generated by AI) into actual Streamlit components.
This is the bridge between AI-generated specifications and visible UI.
"""

import logging
from typing import Any, Callable

import streamlit as st

from .generator import UISpec, UIComponent, ComponentType

logger = logging.getLogger(__name__)


class StreamlitRenderer:
    """
    Renders AI-generated UISpec to Streamlit.

    The renderer interprets component specifications and
    creates corresponding Streamlit elements.
    """

    def __init__(self):
        self._artifact_resolver: Callable[[str], dict] | None = None
        self._graph_renderer: Callable[[dict], Any] | None = None
        self._interaction_handlers: dict[str, Callable] = {}

    def set_artifact_resolver(self, resolver: Callable[[str], dict]) -> None:
        """Set function to resolve artifact IDs to content."""
        self._artifact_resolver = resolver

    def set_graph_renderer(self, renderer: Callable[[dict], Any]) -> None:
        """Set function to render graph visualizations."""
        self._graph_renderer = renderer

    def on_interaction(self, component_id: str, handler: Callable) -> None:
        """Register handler for interactive component."""
        self._interaction_handlers[component_id] = handler

    def render(self, spec: UISpec) -> None:
        """
        Render the complete UI specification.

        Args:
            spec: The UISpec generated by AI
        """
        # Configure page
        if spec.title or spec.page_icon or spec.layout:
            layout = "wide" if spec.layout == "wide" else "centered"
            st.set_page_config(
                page_title=spec.title or "Soul Kiln",
                page_icon=spec.page_icon or "ğŸ”¥",
                layout=layout,
            )

        # Apply theme if specified
        if spec.theme:
            self._apply_theme(spec.theme)

        # Render components
        for component in spec.components:
            self._render_component(component)

    def render_components(self, components: list[UIComponent]) -> None:
        """Render a list of components (for partial updates)."""
        for component in components:
            self._render_component(component)

    def _render_component(self, component: UIComponent, container=None) -> Any:
        """
        Render a single component.

        Args:
            component: The UIComponent to render
            container: Optional Streamlit container to render into

        Returns:
            The Streamlit element (for some component types)
        """
        target = container or st

        # Apply style wrapper if needed
        if component.style:
            # Streamlit doesn't have direct CSS support, but we can use
            # markdown with HTML for some styling
            pass

        # Dispatch to component-specific renderer
        renderer_map = {
            # Layout
            ComponentType.CONTAINER: self._render_container,
            ComponentType.COLUMNS: self._render_columns,
            ComponentType.EXPANDER: self._render_expander,
            ComponentType.TABS: self._render_tabs,

            # Content
            ComponentType.TEXT: self._render_text,
            ComponentType.MARKDOWN: self._render_markdown,
            ComponentType.HEADER: self._render_header,
            ComponentType.SUBHEADER: self._render_subheader,
            ComponentType.CAPTION: self._render_caption,
            ComponentType.CODE: self._render_code,
            ComponentType.DIVIDER: self._render_divider,

            # Media
            ComponentType.IMAGE: self._render_image,
            ComponentType.AUDIO: self._render_audio,
            ComponentType.VIDEO: self._render_video,

            # Data
            ComponentType.DATAFRAME: self._render_dataframe,
            ComponentType.TABLE: self._render_table,
            ComponentType.METRIC: self._render_metric,
            ComponentType.JSON: self._render_json,

            # Charts
            ComponentType.LINE_CHART: self._render_line_chart,
            ComponentType.BAR_CHART: self._render_bar_chart,
            ComponentType.AREA_CHART: self._render_area_chart,
            ComponentType.MAP: self._render_map,
            ComponentType.GRAPH: self._render_graph,

            # Interactive
            ComponentType.BUTTON: self._render_button,
            ComponentType.TEXT_INPUT: self._render_text_input,
            ComponentType.TEXT_AREA: self._render_text_area,
            ComponentType.SELECTBOX: self._render_selectbox,
            ComponentType.SLIDER: self._render_slider,
            ComponentType.CHECKBOX: self._render_checkbox,

            # Special
            ComponentType.ARTIFACT: self._render_artifact,
            ComponentType.CONVERSATION: self._render_conversation,
            ComponentType.VIRTUE_DISPLAY: self._render_virtue_display,
            ComponentType.TOPIC_INDICATOR: self._render_topic_indicator,
        }

        renderer = renderer_map.get(component.type)
        if renderer:
            return renderer(component, target)
        else:
            logger.warning(f"Unknown component type: {component.type}")
            target.warning(f"Unknown component: {component.type}")

    # Layout components
    def _render_container(self, c: UIComponent, target) -> None:
        with target.container():
            for child in c.children:
                self._render_component(child)

    def _render_columns(self, c: UIComponent, target) -> None:
        ratio = c.props.get("ratio", [1] * len(c.children))
        if len(ratio) < len(c.children):
            ratio = [1] * len(c.children)

        cols = target.columns(ratio[:len(c.children)])
        for col, child in zip(cols, c.children):
            self._render_component(child, col)

    def _render_expander(self, c: UIComponent, target) -> None:
        label = c.props.get("label", "Details")
        expanded = c.props.get("expanded", False)
        with target.expander(label, expanded=expanded):
            for child in c.children:
                self._render_component(child)

    def _render_tabs(self, c: UIComponent, target) -> None:
        labels = c.props.get("labels", [f"Tab {i+1}" for i in range(len(c.children))])
        tabs = target.tabs(labels[:len(c.children)])
        for tab, child in zip(tabs, c.children):
            self._render_component(child, tab)

    # Content components
    def _render_text(self, c: UIComponent, target) -> None:
        target.text(c.content or "")

    def _render_markdown(self, c: UIComponent, target) -> None:
        target.markdown(c.content or "")

    def _render_header(self, c: UIComponent, target) -> None:
        target.header(c.content or "")

    def _render_subheader(self, c: UIComponent, target) -> None:
        target.subheader(c.content or "")

    def _render_caption(self, c: UIComponent, target) -> None:
        target.caption(c.content or "")

    def _render_code(self, c: UIComponent, target) -> None:
        language = c.props.get("language", "python")
        target.code(c.content or "", language=language)

    def _render_divider(self, c: UIComponent, target) -> None:
        target.divider()

    # Media components
    def _render_image(self, c: UIComponent, target) -> None:
        caption = c.props.get("caption")
        width = c.props.get("width")
        target.image(c.content, caption=caption, width=width)

    def _render_audio(self, c: UIComponent, target) -> None:
        target.audio(c.content)

    def _render_video(self, c: UIComponent, target) -> None:
        target.video(c.content)

    # Data components
    def _render_dataframe(self, c: UIComponent, target) -> None:
        target.dataframe(c.content, **c.props)

    def _render_table(self, c: UIComponent, target) -> None:
        target.table(c.content)

    def _render_metric(self, c: UIComponent, target) -> None:
        if isinstance(c.content, dict):
            target.metric(
                label=c.content.get("label", ""),
                value=c.content.get("value", ""),
                delta=c.content.get("delta"),
            )
        else:
            target.metric(label="Value", value=c.content)

    def _render_json(self, c: UIComponent, target) -> None:
        target.json(c.content)

    # Chart components
    def _render_line_chart(self, c: UIComponent, target) -> None:
        target.line_chart(c.content)

    def _render_bar_chart(self, c: UIComponent, target) -> None:
        target.bar_chart(c.content)

    def _render_area_chart(self, c: UIComponent, target) -> None:
        target.area_chart(c.content)

    def _render_map(self, c: UIComponent, target) -> None:
        if c.content:
            target.map(c.content)
        else:
            target.info("Map data not available")

    def _render_graph(self, c: UIComponent, target) -> None:
        """Render network graph visualization."""
        if self._graph_renderer and c.content:
            fig = self._graph_renderer(c.content)
            target.pyplot(fig)
        else:
            # Fallback: show as JSON
            target.json(c.content or {"nodes": [], "edges": []})

    # Interactive components
    def _render_button(self, c: UIComponent, target) -> bool:
        label = c.content or c.props.get("label", "Click")
        key = c.props.get("key") or c.id
        clicked = target.button(label, key=key)
        if clicked and c.id in self._interaction_handlers:
            self._interaction_handlers[c.id]()
        return clicked

    def _render_text_input(self, c: UIComponent, target) -> str:
        label = c.props.get("label", "")
        placeholder = c.props.get("placeholder", "")
        key = c.props.get("key") or c.id or "text_input"
        value = c.props.get("value", "")
        return target.text_input(label, value=value, placeholder=placeholder, key=key)

    def _render_text_area(self, c: UIComponent, target) -> str:
        label = c.props.get("label", "")
        placeholder = c.props.get("placeholder", "")
        key = c.props.get("key") or c.id or "text_area"
        height = c.props.get("height", 100)
        return target.text_area(label, placeholder=placeholder, height=height, key=key)

    def _render_selectbox(self, c: UIComponent, target) -> Any:
        label = c.props.get("label", "Select")
        options = c.content or c.props.get("options", [])
        key = c.props.get("key") or c.id
        return target.selectbox(label, options, key=key)

    def _render_slider(self, c: UIComponent, target) -> Any:
        label = c.props.get("label", "Value")
        min_val = c.props.get("min", 0)
        max_val = c.props.get("max", 100)
        value = c.props.get("value", min_val)
        key = c.props.get("key") or c.id
        return target.slider(label, min_val, max_val, value, key=key)

    def _render_checkbox(self, c: UIComponent, target) -> bool:
        label = c.content or c.props.get("label", "")
        value = c.props.get("value", False)
        key = c.props.get("key") or c.id
        return target.checkbox(label, value=value, key=key)

    # Special components
    def _render_artifact(self, c: UIComponent, target) -> None:
        """Render an artifact from the KB."""
        artifact_id = c.content
        artifact_data = c.props

        # Try to resolve if we have a resolver
        if self._artifact_resolver and artifact_id:
            try:
                artifact_data = self._artifact_resolver(artifact_id)
            except Exception as e:
                logger.debug(f"Could not resolve artifact {artifact_id}: {e}")

        if not artifact_data:
            target.warning(f"Artifact not found: {artifact_id}")
            return

        artifact_type = artifact_data.get("type", "unknown")
        title = artifact_data.get("title", artifact_id)
        content = artifact_data.get("content")

        # Render based on type
        if artifact_type == "image":
            caption = artifact_data.get("metadata", {}).get("caption") or title
            target.image(content, caption=caption)

        elif artifact_type == "document":
            with target.expander(f"ğŸ“„ {title}", expanded=True):
                target.markdown(content)

        elif artifact_type == "document_section":
            target.subheader(title)
            target.markdown(content)

        elif artifact_type == "map":
            target.subheader(f"ğŸ“ {title}")
            if isinstance(content, dict) and "lat" in content:
                import pandas as pd
                df = pd.DataFrame([content])
                target.map(df)
            else:
                target.json(content)

        elif artifact_type == "timeline":
            target.subheader(f"ğŸ“… {title}")
            stages = content.get("stages", []) if isinstance(content, dict) else []
            current = content.get("current_stage") if isinstance(content, dict) else None
            for i, stage in enumerate(stages):
                icon = "âœ…" if i < (current or 0) else ("â–¶ï¸" if i == current else "â¬œ")
                target.markdown(f"{icon} **{stage.get('name', f'Stage {i+1}')}**")
                if stage.get("description"):
                    target.caption(stage["description"])

        elif artifact_type == "checklist":
            target.subheader(f"â˜‘ï¸ {title}")
            items = content.get("items", []) if isinstance(content, dict) else []
            for item in items:
                checked = item.get("checked", False)
                icon = "âœ…" if checked else "â¬œ"
                target.markdown(f"{icon} {item.get('text', '')}")

        elif artifact_type == "comparison":
            target.subheader(f"âš–ï¸ {title}")
            if isinstance(content, dict):
                options = content.get("options", [])
                criteria = content.get("criteria", [])
                if options:
                    import pandas as pd
                    rows = []
                    for opt in options:
                        row = {"Option": opt.get("name", opt.get("id", ""))}
                        row.update(opt.get("values", {}))
                        rows.append(row)
                    if rows:
                        target.dataframe(pd.DataFrame(rows))

        else:
            # Generic fallback
            target.subheader(title)
            if isinstance(content, str):
                target.markdown(content)
            else:
                target.json(content)

    def _render_conversation(self, c: UIComponent, target) -> None:
        """Render conversation history in chat style."""
        conversation = c.content or []
        show_last = c.props.get("show_last", 10)

        if show_last and len(conversation) > show_last:
            conversation = conversation[-show_last:]

        for turn in conversation:
            role = turn.get("role", "user")
            content = turn.get("content", "")
            name = turn.get("name")

            if role == "user":
                with target.chat_message("user"):
                    target.write(content)
            elif role == "assistant":
                with target.chat_message("assistant", avatar="ğŸ”¥"):
                    if name:
                        target.caption(name)
                    target.write(content)
            else:
                with target.chat_message("assistant"):
                    if name:
                        target.caption(f"{role}: {name}")
                    target.write(content)

    def _render_virtue_display(self, c: UIComponent, target) -> None:
        """Render virtue activation visualization."""
        show_activations = c.props.get("show_activations", True)
        virtues = c.content or c.props.get("virtues", [])

        if not virtues:
            # Default virtue list
            virtues = [
                {"id": "V01", "name": "Trustworthiness", "activation": 0.8},
                {"id": "V02", "name": "Truthfulness", "activation": 0.6},
                {"id": "V03", "name": "Justice", "activation": 0.5},
            ]

        target.subheader("Virtue Activations")

        for virtue in virtues:
            name = virtue.get("name", virtue.get("id", "?"))
            activation = virtue.get("activation", 0)

            if show_activations:
                target.progress(activation, text=f"{name}: {activation:.0%}")
            else:
                target.text(name)

    def _render_topic_indicator(self, c: UIComponent, target) -> None:
        """Render current topic indicator."""
        topic_state = c.content or {}

        region = topic_state.get("primary_region", "unknown")
        confidence = topic_state.get("confidence", 0)
        concepts = topic_state.get("active_concepts", [])[:5]

        # Color map for regions
        region_colors = {
            "foundation": "ğŸŸ¤",
            "core": "ğŸ”µ",
            "relational": "ğŸŸ¢",
            "personal": "ğŸŸ¡",
            "transcendent": "ğŸŸ£",
            "technical": "âšª",
            "practical": "ğŸŸ ",
        }

        icon = region_colors.get(region, "â¬œ")
        target.markdown(f"**Topic:** {icon} {region.title()} ({confidence:.0%} confidence)")

        if concepts:
            target.caption(f"Active: {', '.join(concepts)}")

    def _apply_theme(self, theme: dict) -> None:
        """Apply theme colors (limited support in Streamlit)."""
        # Streamlit's theming is limited to config.toml
        # We can inject some CSS for basic customization
        primary = theme.get("primary_color", "#FF6B6B")
        background = theme.get("background", "#FFFFFF")

        css = f"""
        <style>
        .stApp {{
            background-color: {background};
        }}
        .stButton > button {{
            background-color: {primary};
            color: white;
        }}
        </style>
        """
        st.markdown(css, unsafe_allow_html=True)


# Singleton
_renderer: StreamlitRenderer | None = None


def get_renderer() -> StreamlitRenderer:
    """Get the singleton renderer."""
    global _renderer
    if _renderer is None:
        _renderer = StreamlitRenderer()
    return _renderer
